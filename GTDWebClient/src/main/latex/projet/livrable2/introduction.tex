\chapter{Introduction}


\section{Objectif}
Dans ce second livrable, nous allons décrire l'ensemble des fonctionnalités du logiciel à développer. Ce logiciel devra permettre à l'utilisateur d'organiser ses tâches selon la méthode GTD décrite dans le premier livrable.
L'objectif de ce livrable est de fournir une description du comportement de notre application. De ce fait, les contraintes fonctionnelles permettront par le biais de cas d'utilisation de préciser le comportement du logiciel. Nous préciserons cela grâce à des sous cas d'utilisation du livrable 1. De plus, les critères d'utilisation tels que la fiabilité, l'utilisabilité ou la performance feront l'objet de besoins non-fonctionnels.

\section{Conventions}
%<Describe any standards or typographical conventions that were followed when writing this SRS, such as fonts or highlighting that have special significance. For example, state whether priorities  for higher-level requirements are assumed to be inherited by detailed requirements, or whether every requirement statement is to have its own priority.>
Dans la suite du document, les notions évoquées dans le premier livrable sont considérées comme acquises. Cependant, lorsque cela sera nécessaire, des références vers le premier livrable seront utilisées. Nous distinguons 4 actions bien distinctes issues du premier livrable :\\

\begin{itemize}
\item La collecte des informations =  Collect
\item Le traitement des informations =  Process
\item L'oganisation des tâches = Organize
\item La révision des tâches (maj) = Revue
\end{itemize}

\medskip

Nous utiliserons donc ces raccourcis pour nommer ci-besoin, l'action courante que l'utilisateur effectue.

	\section{Audience}
%<Describe the different types of reader that the document is intended for, such as developers, project managers, marketing staff, users, testers, and documentation writers. Describe what the rest of this SRS contains and how it is organized. Suggest a sequence for reading the document, beginning with the overview sections and proceeding through the sections that are most pertinent to each reader type.>
Ce document est destiné à être utilisé par l'ensemble des participants au projet. Après approbation, il sera considéré comme document de référence.
	
	\section{Portée du document}
%Une brève description de la portée de ce document, l’application qu’il décrit, les caractéristiques ou autres sous-systèmes auxquels l’application est associée, le ou les modèles de cas d’utilisation qu’il décrit ainsi que tout autre chose qui peut être influencée ou affectée par ce document.
Le développement du logiciel va s'appuyer sur ce document. Ainsi, chaque élément décrit dans ce livrable va directement influencer le reste des livrables. Comme il est indiqué précédemment, ce livrable s'appuie sur l'analyse de GTD réalisée dans le livrable 1.  

	\section{Définitions, acronymes et abréviations}
	%Énumérer les définitions de tous les termes, acronymes et abréviations nécessaires à la compréhension du document d’architecture logicielle. Cette information peut renvoyer à l’artéfact Glossaire du projet..
	Afin de bien cerner les éléments relatifs à la méthode GTD (Getting Things Done) la lecture du livrable 1 est nécessaire, en particulier le dictionnaire de données.
  
	%\section{Références}
%Cette section comporte la liste de tous les documents cités dans le document. Chaque document doit être identifié par son titre, son numéro, lorsque applicable, sa date et l’organisation qui l’a publiée. Les sources qui peuvent fournir les références doivent être citées. Cette dernière information peut être elle-même une référence à une annexe ou à un autre document.%

	\section{Organisation du chapitre}
Dans un premier temps, les besoins fonctionnels seront détaillés. Ces besoins doivent définir le comportement attendu du système. Pour cela nous expliciteront à l'aide de cas d'utilisation.

\medskip

Dans une seconde partie, les besoins non-fonctionnels permettant de caractériser l'environnement dans lequel le système doit fonctionner, seront détaillées. Ils peuvent être vus comme des contraintes d'utilisation, mais aussi comme des critères de qualité du développement du logiciel.

